/*****************************************************************************
#
# Copyright 2026
#   Murayyiam Parvez (Purdue University),
#   Annus Zulfiqar (University of Michigan),
#   Roman Beltiukov (University of California, Santa Barbara),
#   Shir Landau Feibish (The Open University of Israel),
#   Walter Willinger (NIKSUN Inc.),
#   Arpit Gupta (University of California, Santa Barbara),
#   Muhammad Shahbaz (University of Michigan)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# *****************************************************************************/

/*************************************************************************
************************ INGRESS *****************************************
*************************************************************************/

parser IngressParser(
    packet_in pkt,
    out headers_t hdr,
    out metadata_t ig_md,
    out ingress_intrinsic_metadata_t ig_intr_md)
{
    state start {
        pkt.extract(ig_intr_md);
        pkt.advance(PORT_METADATA_SIZE);
        transition select(ig_intr_md.ingress_port) {
            RECIRCULATE_PORT : parse_resubmit;
            default          : parse_ethernet;
        }
    }

    state parse_resubmit {
        pkt.extract(hdr.resubmit_hdr);
        transition accept;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4 : parse_ipv4;
            default   : accept;
        }
    }

    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            6  : parse_tcp;
            17 : parse_udp;
            default : parse_features;
        }
    }

    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition parse_features;
    }

    state parse_udp {
        pkt.extract(hdr.udp);
        transition parse_features;
    }

    state parse_features {
        pkt.extract(hdr.features);
        transition accept;
    }
}

/*************************************************************************
************************ INGRESS CONTROL *********************************
*************************************************************************/

control Ingress(
    inout headers_t hdr,
    inout metadata_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)
{

    /************ HASH ************/
    Hash<bit<KEY_SIZE>>(HashAlgorithm_t.CRC32) crc32;

    action hash_packet(
        bit<32> ipAddr1,
        bit<32> ipAddr2,
        bit<16> port1,
        bit<16> port2,
        bit<8>  proto)
    {
        ig_md.flow_hash = crc32.get({ ipAddr1, ipAddr2, port1, port2, proto });
    }

{% include "ingress_registers.j2" %}
{% include "ingress_register_actions.j2" %}
{% include "ingress_encode_and_control.j2" %}
{% include "ingress_stateful_dispatch.j2" %}
{% include "ingress_stateless_operand_load.j2" %}
{% include "ingress_operand_load_tables.j2" %}
{% include "ingress_stateful_op_tables.j2" %}
{% include "ingress_feature_encode_tables.j2" %}
{% include "ingress_classifier.j2" %}
{% include "ingress_reg_index.j2" %}
{% include "ingress_apply_block.j2" %}

    
}

/*************************************************************************
************************ DEPARSE *****************************************
*************************************************************************/

control IngressDeparser(
    packet_out pkt,
    inout headers_t hdr,
    in metadata_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md)
{
    Digest<digest_a_t>() digest_a;

    apply {
        if (ig_dprsr_md.digest_type == L2_LEARN_DIGEST) {
            hdr.digest_a.setValid();
            hdr.digest_a.srcAddr  = ig_md.src_addr;
            hdr.digest_a.dstAddr  = ig_md.dst_addr;
            hdr.digest_a.src_port = ig_md.src_port;
            hdr.digest_a.dst_port = ig_md.dst_port;
            hdr.digest_a.protocol = hdr.ipv4.protocol;
            digest_a.pack(hdr.digest_a);
        }
        pkt.emit(hdr.resubmit_hdr);
    }
}
